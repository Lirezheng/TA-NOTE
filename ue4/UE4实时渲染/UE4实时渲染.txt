---
typora-copy-images-to: shader\ue4\UE4实时渲染图片
---

确定target framerate

![image-20210629154713550](https://i.loli.net/2021/06/29/qTeAXUEjQ1KMJFi.png)

延迟渲染的特点：


![image-20210629160145242](UE4实时渲染图片\image-20210629160145242.png)

 

前向渲染的特点：

![image-20210629160614541](UE4实时渲染图片\image-20210629160614541.png)



移动端应用多用前向渲染，主机游戏多用延迟渲染。





## 渲染前：



![image-20210629160754605](UE4实时渲染图片\image-20210629160754605.png)

三者工作是同步的。

CPU是最先参与的，因为它要处理渲染之前的问题。

整体流程：

CPU：在时间0开始处理一系列逻辑和转换问题。

DRAW:

![image-20210629161644842](UE4实时渲染图片\image-20210629161644842.png)



距离剔除：超出一定范围，引擎将不会渲染。默认情况将不会开启。

![image-20210629161840475](UE4实时渲染图片\image-20210629161840475.png)



也可以为每个对象单独设置剔除距离。

![image-20210629162010842](UE4实时渲染图片\image-20210629162010842.png)





视锥体切除：

对象在视角之外或处于边缘，引擎会剔除或剪切该对象。

![image-20210629162156902](UE4实时渲染图片\image-20210629162156902.png)



预计算可见性：

场景会被切分为单元，单元格（grid cell）会记忆该位置什么是可见的。

![image-20210629162718502](UE4实时渲染图片\image-20210629162718502.png)

如何查看：Settings-World Settings-勾选Precompute Visbility



遮挡剔除：

精确检测每个模型的可见性。

使用Freezerendering可视化遮挡剔除过程。



全流程处理数据：

使用Stat Initviews命令，可以看到四个阶段处理数据。



一些需要注意的点：

![image-20210629165242508](UE4实时渲染图片\image-20210629165242508.png)

重要：设置距离剔除。

开放世界类型要进行优化分析因为遮挡作用小。

小模型和大模型要兼顾使用，大模型一旦通过遮挡检测便会增加GPU复合，因为它的组成没有很多小模型对象。

任何对象都能被遮挡，包括粒子对象。粒子对象是通过包围盒遮挡的。





GPU渲染：

![image-20210629165117933](UE4实时渲染图片\image-20210629165117933.png)



## 几何体渲染：

Prepass/Z Early Pass:防止重复计算同一区域的像素。通过一个前期的Z深度测试预先渲染。

Drawcalls：渲染指令，方式：逐Drawcalls渲染。Drawcalls对性能影响很大，甚至比多边形数量大得多。例如搬移数据，一个对象是1GB的文件搬移速度远比由很多个对象大小总和为1GB的搬移速度快。同时，Drawcalls后需要等待指令，因此时间消耗增加不可避免，这就是为什么我们需要对Drawcalls进行批处理。另外，材质的使用也会增加Drawcalls数量。‘stat THI’ 以查看Drawcalls和三角渲染数量。

一些标准：

![image-20210629171735900](UE4实时渲染图片\image-20210629171735900.png)



Drawcalls性能影响：

![image-20210629192815758](UE4实时渲染图片\image-20210629192815758.png)

同时Components 也会进行Drawcalls

建议：尽量少使用大模型。因为碰撞检测会传输与整个大模型的交互数据。大模型内存需求更高。

如何改善：模块化网格体。

![image-20210629194544481](UE4实时渲染图片\image-20210629194544481.png)



具体方法：

![image-20210629194916923](UE4实时渲染图片\image-20210629194916923.png)



1.进入Window-Statistics，选择Primitive stats。根据使用数、面数和总面数合并。合并的模型面数需要合理。

![image-20210629195614093](UE4实时渲染图片\image-20210629195614093.png)

Count：使用次数。

Tris：模型面数：

Sum Tris：总面数。



2.实例化静态网络体渲染。

通常对草地等大量对象使用，可以快速渲染大量对象，几乎不会有性能损耗。

3.LOD，细节层次。减面模型，减少多边形，减少内存使用，但不会减少Drawcalls。

HLOD:将对象编组，距离足够远时，仅使用单一模型来替换这一组的对象。

![image-20210629200926009](UE4实时渲染图片\image-20210629200926009.png)

![image-20210629201020072](UE4实时渲染图片\image-20210629201020072.png)



Vertex shaders

shaders类型多种，顶点shaders是其中之一，且是第一个。

什么是shader：一段程序根据输入变量输出不同结果。



vertex shaders：可看成物体坐标到世界坐标的偏移，这其中我们可以对偏移再进行一次偏移，从而实现更多的视觉效果。

用顶点着色器实现动画比单纯利用CPU进行每帧计算顶点位置优化更好。因为对像只是渲染在其它位置，本身并没有移动。碰撞由CPU负责，顶点偏移后碰撞盒并没有发生改变。因此顶点 偏移不能用于定位和触发等。

![image-20210629201850208](UE4实时渲染图片\image-20210629201850208.png)

关于性能：

![image-20210629202452985](UE4实时渲染图片\image-20210629202452985.png)

特别：远距离时要对顶点动画进行限制。





## 光栅化和GBuffer



OverShading过度着色：让着色范围超出本应有的范围。同时，若覆盖相同的区域，则会进行第二次像素处理，也即第二次Overshading。

![image-20210630163006968](UE4实时渲染图片\image-20210630163006968.png)

![image-20210630163311904](UE4实时渲染图片\image-20210630163311904.png)

可视化：调用Quard Overdraw观察近距离与远距离的渲染损耗。

![image-20210630163556516](UE4实时渲染图片\image-20210630163556516.png)

1.多边形密度越大损耗越高，因此需要采取依距离多边形减面或剔除。



过度着色的例子：
![image-20210630164449700](UE4实时渲染图片\image-20210630164449700.png)

多边形在靠近圆心时，圆心周围多边形密度骤升，因此发生了过度着色，导致渲染结果看起来黑。





G-Buffer：

用于合成各种内容，如光照、雾效等。占用大量内存和带宽。



Custom Depth：

自定义深度：将对象剥离环境，使用单独渲染目标或G-Buffer包含某一模型，然后用于实现特效。

开启：Detail面板下搜索 custom

可视化：viewport Options下

![image-20210630165526323](UE4实时渲染图片\image-20210630165526323.png)



## Rendering and Texture



纹理格式：BC(DXTC)用于PC，BC-块压缩，DXTC-DX纹理压缩。

法线图使用特别的BC5压缩方法，它只需RG通道，B通道通常是额外计算的。

几种压缩方法：

![image-20210630170330368](UE4实时渲染图片\image-20210630170330368.png)



PS中存储格式：Intel Texture Works保存DDS文件，是用于BC3格式的。

纹理分辨率会影响内存和带宽，通常会导致延迟和卡帧，而不会持续导致帧率下降。



Mipmaps：

多级渐进纹理，由原纹理和很多1/4大小的纹理组成，作用是最大化内存效率和使图像更为顺滑。通过纹理内部LOD Bias调节可以查看各层级图像。

![image-20210630171425969](UE4实时渲染图片\image-20210630171425969.png)





## 像素着色器和材质



pixel shaders：由GPU执行，逐像素修改像素的颜色。它的作用：

![image-20210630172828445](UE4实时渲染图片\image-20210630172828445.png)



shaders 工作流：

![image-20210630173203597](UE4实时渲染图片\image-20210630173203597.png)



shaders 在UE中的工作流：
![image-20210630173347884](UE4实时渲染图片\image-20210630173347884.png)



材质面板中Usage选项：着色器使用。每个情况都会产生shaders编译。

RenderDoc中的渲染管线：

<img src="UE4实时渲染图片\image-20210630174035449.png" alt="image-20210630174035449" style="zoom: 200%;" />





Shading Model ：对一些输入选项进行遮罩处理，因为有些材质不需要PBR渲染。





关于shaders 和材质性能：

shaders 和材质最大纹理采样通常是13可用（16中3个被占用），DX11以上共享采样器采样可达128.

为什么进入游戏有时看到是低模的：电脑没有足够带宽或内存快速传输完整分辨率的纹理，因此它会先用Mipmaps或Lod。

对于性能方面通常考虑以下几点：Drawcalls数量，像素着色器，半透明，动态阴影渲染。





## 反射



Reflection  Captures（反射捕捉）：特定位置捕捉静态cubemap并与材质Blend。

特点：预先计算得到，不够准确，但快速。

Planar Reflections（镜面反射）：不常使用，常使用在一定范围内的平滑平面，如镜子，可以动态改变，不过占用很大空间。

Screen Space Reflection（SSR）：默认的反射系统，精确实时的且不用预先计算。但是输出会有噪声、渲染损耗大，且只能渲染屏幕上出现的内容。

![image-20210630225242350](UE4实时渲染图片\image-20210630225242350.png)

UE4里被归于PostProcessVol中。

优先级顺序：SSR-PR-RC



关于反射性能：未烘培前，过多的反射捕捉会让加载变慢。反射捕捉叠加会变得臃肿，因为像素着色过度，最好控制在8次反射捕捉叠加以下。反射捕捉的锐利程度可以通过设置分辨率改变。

tips：项目设置中搜索：Reflection中可以设置反射捕捉分辨率。最好设置反射捕捉时能尽量不重叠。

使用天空光照（sky light）：低消耗，可作为世界的备用反射捕捉。

非必要不适用PR，硬件性能有限考虑关闭SSR，若性能好可以开高降低一些噪声：

指令键入r.SSR.Quality,默认设置为3.



![image-20210630234848957](UE4实时渲染图片\image-20210630234848957.png)

## 静态照明

预先计算或预先渲染的光照或阴影。

优缺点：![image-20210630235112799](UE4实时渲染图片\image-20210630235112799.png)

![image-20210630235220990](UE4实时渲染图片\image-20210630235220990.png)

什么叫Lightmaps：纹理烘培有光照和阴影信息。这个纹理将会与basecolor相乘后，使其看起来就像被光照亮一样。

具体实现过程：在UE4中lightmaps会被lightmass打包。

![image-20210630235645180](UE4实时渲染图片\image-20210630235645180.png)

Lightmass：独立应用，用来控制光照渲染并将其烘培到光照贴图中、支持网格式分布渲染、

![image-20210701000614877](UE4实时渲染图片\image-20210701000614877.png)

设置光照质量：

1.world setiting里

![image-20210701000054079](UE4实时渲染图片\image-20210701000054079.png)

2.Lighting 里的Lighting Quality。

![image-20210701000149645](UE4实时渲染图片\image-20210701000149645.png)

3.放置LighmassImportantVolume到需要较高质量光照的场景。



ILC：间接光照缓存。用于处理动态模型在预计算光照下的显示。通过在LI体中分散成3D网格向量，存储当前位置的光照强度并用于动态模型照明。

![image-20210701001256127](UE4实时渲染图片\image-20210701001256127.png)

UV布局必须要存在。



关于静态光照性能：烘培后快，渲染速度总是相同的，静态光照数量在烘培后不重要，光照贴图影响内存和文件大小，不影响帧速率。

烘培时间增加原因：光照贴图分辨率，模型和光照数量，更高级的光照设置，更大的光照衰减半径和光源半径。

![image-20210701002158637](UE4实时渲染图片\image-20210701002158637.png)

增加性能：Lightmap Density 下观察UV和颜色。一些不需要高分辨的模型可以在Detail下调控

![image-20210701002907826](UE4实时渲染图片\image-20210701002907826.png)

## 动态照明

动态照明优缺点：

![image-20210701111556024](UE4实时渲染图片\image-20210701111556024.png)

![image-20210701111801757](UE4实时渲染图片\image-20210701111801757.png)

动态阴影：

Regular Dynamic Shadows（常规动态阴影）：常用。灯光Mobility设置为Movable。下图可以看到，动态阴影边角分明，阴影处黑因为没有反射光照，只是阴影跟lightmap混合。

![image-20210701112255292](UE4实时渲染图片\image-20210701112255292.png)



Per Object Shadows(逐对象阴影)：又称固定光源阴影。灯光Mobility设置为Stationary，阴影混合使用完全依赖lightmaps的静态光照和完全动态光照，兼具。下图，锐利程度下降

![image-20210701113456733](UE4实时渲染图片\image-20210701113456733.png)



CSM-Cascaded Shadow Maps（次级联）：直接光照阴影，灯光使用：DirectionalLightStationary。

随着摄像机距离，使用的阴影分辨率不同。只适用于小场景。

设置![image-20210701114004543](UE4实时渲染图片\image-20210701114004543.png)



Distance Field Shadows（距离场阴影）：使用距离场代替追踪几何信息。

“投射阴影需要知道点之间的距离，这就需要询问和比较，该过程较慢。”

UE4中使用距离场，加快计算两点之间的距离并储存在体纹理中，体纹理分辨率决定投射阴影的细节，但它不够细节，

![image-20210701114310538](UE4实时渲染图片\image-20210701114310538.png)

体积纹理的创建：

![image-20210701114803559](UE4实时渲染图片\image-20210701114803559.png)

项目设置中搜索Gnerate Mesh Distance Fields勾选建立静态网格距离场。Visualize中勾选Mesh Distance Fields观察距离场。

其它阴影：![image-20210701115542783](UE4实时渲染图片\image-20210701115542783.png)

- 通常角色可以使用Inset Shadows，没有合适光源也会投射高分辨阴影。
- Contact Shadows，适用于小细节。
- Capsule Shadows：简单损耗小面数低，常用来渲染角色底部的阴影。

灯光下：Performance-Max Draw Distance可以根据距离控制阴影。

项目中有意思的设置：两盏灯光，一盏半径大但是是Static的，一盏半径小亮度高但是是Dy的。

像素着色：

灯光在UE4中会创建一个相当于像球体的遮罩，白色部分需要额外计算光照，黑色部分不用。若光源球体重叠，将会反复计算像素。

![image-20210701120709314](UE4实时渲染图片\image-20210701120709314.png)



![image-20210701121128360](UE4实时渲染图片\image-20210701121128360.png)

![image-20210701121201529](UE4实时渲染图片\image-20210701121201529.png)

除了摄像机画面中的距离信息，还要有光源与几何体的距离信息。

![image-20210701121336544](UE4实时渲染图片\image-20210701121336544.png)

利用这些信息生成阴影贴图。

![image-20210701121518629](UE4实时渲染图片\image-20210701121518629.png)



关于动态光照性能：

![image-20210701121756026](UE4实时渲染图片\image-20210701121756026.png)

延迟渲染中消耗相对低。画面中有动态光照的像素越多越慢。DL必须尽可能小并防止重叠和过多。

radius过大，导致需要计算的像素也变多。

![image-20210701122156537](UE4实时渲染图片\image-20210701122156537.png)



关于阴影性能：

![image-20210701131900795](UE4实时渲染图片\image-20210701131900795.png)

使用距离关闭阴影以达到更好的优化。在每个灯光下可设置：

![image-20210701132236880](UE4实时渲染图片\image-20210701132236880.png)



有趣的设置：设置两盏灯，一盏为静态static半径大的，一盏为动态Movable半径小的，

## 雾和照明度



Distance Fog（基于像素着色的距离雾，）：

- Atmospheric and Exponentional fog（大气雾性能好点，指数雾效果好点因为可以混合各种颜色）。
- local volumetric fog
- 雾会随着距离消隐，同时它们也是高度雾，也会随着与天空的距离消隐。



关于半透明性能：

![image-20210701133839939](UE4实时渲染图片\image-20210701133839939.png)

![image-20210701133914903](UE4实时渲染图片\image-20210701133914903.png)

## 后期处理



什么是Post Processing

![image-20210701134145270](UE4实时渲染图片\image-20210701134145270.png)



实现效果举例：

![image-20210701134248223](UE4实时渲染图片\image-20210701134248223.png)



Bloom实现原理：找到一张明暗对比度强的照片，模糊，混合一张照片，在混合原图。

世界框架搜索：Global PostProcessVolume，在Lens下找到Bloom。



LUT-Look Up Table（查找表）：存储颜色记录和颜色变化。存储颜色偏移并在引擎中用此偏移。总颜色4096.

![image-20210701135548232](UE4实时渲染图片\image-20210701135548232.png)

![image-20210701135737906](UE4实时渲染图片\image-20210701135737906.png)



enjoy！