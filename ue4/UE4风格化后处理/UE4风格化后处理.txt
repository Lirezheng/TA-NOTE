---
typora-copy-images-to: UE4风格化后处理图片

---

Stylized



## 前置概要

UE中默认后处理会有eye adaptation，以模拟人眼变化。那么如何关闭？创建一个后处理Volume，在Exposure（曝光）下使最大/小亮度相等。

![image-20210719231002710](UE4风格化后处理图片\image-20210719231002710.png)





传统卡通中没有动态模糊，因此可以在Rendering Features 下的Motion Blur 设置 Amount 值为0.

![image-20210719231222849](UE4风格化后处理图片\image-20210719231222849.png)





UE中默认会使用TAA（临时抗锯齿）。TAA如何运作？首先抖动图像，然后将平均结果叠加到原图像。所以如果PPM中只有Scenen Texture输入，就能明显观察到抖动现象。

如何改变渲染中抗锯齿的方式。Project Settings->Rendering->Default Settings下修改。

![image-20210720000532101](UE4风格化后处理图片\image-20210720000532101.png)

- MSAA用于前向渲染，而我们默认渲染方式是延迟渲染，因而不可用。
- FXAA，快速近似抗锯齿，使用深度算法查找边缘，使用像素混合算法解决锯齿。



我们依旧使用TAA，那么如何去除TAA的抖动呢，我们进入PPM中的“可混合位置”。选择Before Tonemapping，可以看到锯齿明显减少。

![image-20210720001547051](UE4风格化后处理图片\image-20210720001547051.png)

1. After Tonemapping，色调映射后。后期处理最后阶段，将Gbuffer从低动态范围空间内提取出来。
2. Before Tonemapping，色调映射前。将在高动态范围空间内提取基础颜色。
3. Before Translucency，半透明前。在任何半透明效果应用到图像前。
4. Replacing the Tonemapper，替换色调映射器。完全禁用色调映射器，以使用自己创建的。
5. Screen Space Reflection Input，屏幕空间反射输入。将使用当前任意Gbuffer作为屏幕空间反射。



官方文档。

![image-20210720014308835](UE4风格化后处理图片\image-20210720014308835.png)

| **色调映射前（Before Tonemapping）**           | PostProcessInput0为HDR中的所有照明提供场景颜色。用它来修复时间抗锯齿和GBuffer查找的问题，如深度，法线。 |
| ---------------------------------------------- | ------------------------------------------------------------ |
| **色调映射后（After Tonemapping）**            | 首选性能位置，因为颜色是LDR，因此需要的精度和带宽较少。这是在色调映射和颜色分级之后。 |
| **半透明前（Before Translucency）**            | 这在通道中甚至比半透明与场景颜色结合之前的"色调映射前"还要早。注意SeparateTranslucency的混合比法线透明度要晚。 |
| **替换色调映射器（Replacing the Tonemapper）** | PostProcessInput0为HDR提供场景颜色，PostProcessInput1具有SeparateTranslucency（Alpha是遮罩），PostprocessInput2具有低分辨率泛光输入。 |

典型的后期处理输入来自以前的通道。当使用 **PostProcessInput0** 时，可以通过SceneTexture材质表达式访问该颜色。使用SceneColor可能不会得到正确的结果。

## 描边效果



![image-20210720010233806](UE4风格化后处理图片\image-20210720010233806.png)

Size：图像分辨率大小。

InvSize：反转尺寸，允许执行边缘检测或Sobel操作。



官方：

**UV** 输入允许您指定要进行纹理查找的位置（仅用于颜色输出）。 颜色输出是4通道输出（实际的通道分配取决于场景纹理id）。

**大小（Size）** 是一个包含纹理宽度和高度的 两分量矢量。

该两分量矢量的倒数（1/宽度、1/高度）在 **InvSize** 输出中获得。在引用如下例所示的邻近样本时， 它非常方便。



因此利用InvSize，我们可以使用一个2Vector来对X和Y方向进行一个单位的偏移以此达到描边效果。

![image-20210720014711851](UE4风格化后处理图片\image-20210720014711851.png)

但由于深度偏移值相加，最终结果可能大于1，因此我们要用Clmap函数进行限制。

![image-20210720110947594](UE4风格化后处理图片\image-20210720110947594.png)

![image-20210720110955898](UE4风格化后处理图片\image-20210720110955898.png)





该偏移是根据SceneDepth的，因此只能得到多边形的描边效果，接下来介绍对法线的描边。

![image-20210720163328666](UE4风格化后处理图片\image-20210720163328666.png)

与深度偏移类似，将世界法线进行X和Y的偏移我们可以得到如下结果。

![image-20210720163722434](UE4风格化后处理图片\image-20210720163722434.png)

原Gbuffer中世界法线图：

![image-20210720163911688](UE4风格化后处理图片\image-20210720163911688.png)

世界法线图中看出，当两个像素点的朝向有较大差异时，对法线做略微的偏移并作为UV查找颜色，与原法线相减，会使得转向处颜色值变化巨大;而那些较为平滑的面由于法线朝向差异不大，因此相减后几乎为0，成像结果为黑色。

对上述偏移再做四次叠加，即可对四个方向有较好的偏移效果。同时，法线描线的结果颜色较为丰富，我们需要做去饱和处理以便于与多边形描边结果相加。

![image-20210720165101130](UE4风格化后处理图片\image-20210720165101130.png)



完善描边。

描边线条过于细小，难以看出其结构，因此可以对偏移量进行修改。

![image-20210720165234102](UE4风格化后处理图片\image-20210720165234102.png)

偏移量操作。

![image-20210720165813643](UE4风格化后处理图片\image-20210720165813643.png)

有时远处模型上的描边细节过多，我们需要进行减少描边次数和增加对比度的方法以减少该现象，同时减少抖动。

![image-20210720170441900](UE4风格化后处理图片\image-20210720170441900.png)



该范例得到法线细节更多的图像。

![image-20210720170829347](UE4风格化后处理图片\image-20210720170829347.png)

![image-20210720170918746](UE4风格化后处理图片\image-20210720170918746.png)



Contrast为0.5时，多余的描边就更多了，因此要增加对比度，减少描边次数。

![image-20210720171221274](UE4风格化后处理图片\image-20210720171221274.png)









## 遮罩

关于Custom Depth“自定义深度”,它允许我们找到自定义深度的对象。

![image-20210720195138882](UE4风格化后处理图片\image-20210720195138882.png)

对象开启Custom Depth后，将会在CustomDepth的Pass中渲染。那么如何设置Custom Depth呢？找到对象Detail。勾选该Pass选项。

![image-20210720224050671](UE4风格化后处理图片\image-20210720224050671.png)



我们重建一个PPM用于遮罩。如下图，开启Pass的对象的深度值减去场景深度值应该是等于0的。而对象之外的其它场景，由于没有开启CustomDepth，默认为1.

![image-20210720224758510](UE4风格化后处理图片\image-20210720224758510.png)

![image-20210720230023641](UE4风格化后处理图片\image-20210720230023641.png)

由于我们是对人物进行遮罩，因此上述节点Minus即可。

![image-20210720230128504](UE4风格化后处理图片\image-20210720230128504.png)

通过遮罩，我们再把原本的基色渲染上去，通过一个Lerp函数即可。

![image-20210720231732776](UE4风格化后处理图片\image-20210720231732776.png)





我们不需要场景描边，因此需要同样的方式在描边PPM中通过Lerp函数去除该操作。

![image-20210720232334639](UE4风格化后处理图片\image-20210720232334639.png)





得到图像如下，观察到人物边界处的描边缺失，因为人物遮罩把偏移的边界包含进去了。这时我们同样可以把遮罩进行一定的偏移，使得多出的遮罩恰好与偏移量相等。

![image-20210720232314850](UE4风格化后处理图片\image-20210720232314850.png)

![image-20210720234032242](UE4风格化后处理图片\image-20210720234032242.png)

操作四次即可。

![image-20210720234113974](UE4风格化后处理图片\image-20210720234113974.png)

Enjoy！



但问题还未解决，但对象距离过远，最终会出现该现象。没错一团黑，十分的臭。

![image-20210720234757618](UE4风格化后处理图片\image-20210720234757618.png)

描边时没有受景深影响，进入角色遮罩材质里，设置半透明前。

![image-20210721010252553](UE4风格化后处理图片\image-20210721010252553.png)







## 设置关下遮罩



我们使用后处理输入除以Bbuffer中的Basecolor以得到光照信息。并将其结果钳制以使天空光照信息得到修正并使天空抖动消失。

![image-20210721122056784](UE4风格化后处理图片\image-20210721122056784.png)

有了光照信息，我们就可以设定一个光照衰落值，分出暗部和亮部，并让它们分别乘上相应的3Vector以获得漂亮的颜色。

![image-20210721124154237](UE4风格化后处理图片\image-20210721124154237.png)



创建“曲线图集行”。曲线图集行的曲线时间将用于确定曲线的位置信息，光照告知曲线如何渲染。

![image-20210721125042210](UE4风格化后处理图片\image-20210721125042210.png)

Miscellaneous下创建这辆玩意。

![image-20210721125517657](UE4风格化后处理图片\image-20210721125517657.png)

CurveAtlas可以存储现有的曲线。

![image-20210721133721142](UE4风格化后处理图片\image-20210721133721142.png)





## 模糊



使用BlurSampleOffsets进行采样偏移

![image-20210721134312283](UE4风格化后处理图片\image-20210721134312283.png)





. 简单来说，如何通过后期处理材质来实现场景模糊？

选中图像，将其按某个方向稍微移动，并将它们全部堆叠起来。****